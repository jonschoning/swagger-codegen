{-|
Module : {{title}}.API
-}

{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -fno-warn-unused-binds -fno-warn-unused-imports #-}

module {{title}}.API where

import {{title}}.Model as M

import qualified Data.Aeson as A
import qualified Data.Aeson.Types as A

import qualified Data.ByteString as B
import qualified Data.ByteString.Builder as BSB
import qualified Data.ByteString.Char8 as BS8
import qualified Data.ByteString.Lazy.Char8 as BSL

import qualified Network.HTTP.Client as NH
import qualified Network.HTTP.Client.MultipartFormData as NH
import qualified Network.HTTP.Client.TLS as NH
import qualified Network.HTTP.Media as ME
import qualified Network.HTTP.Types as NH
import qualified Network.HTTP.Types.Method as NH
import qualified Network.HTTP.Types.URI as NH

import qualified Web.HttpApiData as WH
import qualified Web.FormUrlEncoded as WH

import qualified Data.CaseInsensitive as CI
import qualified Data.Data as P (Typeable)
import qualified Data.Foldable as P
import qualified Data.Functor.Identity as P (Identity(..))
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Proxy as P (Proxy)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import qualified Data.Vector as V
import qualified Data.Void as Void
import qualified GHC.Base as P (Alternative)

import Control.Monad.IO.Class
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Set (Set)
import Data.Text (Text)
import GHC.Base ((<|>))

import Prelude (($), (.),(<$>),(<*>),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty)
import qualified Prelude as P

-- * Operations
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}

-- ** {{operationId}}

-- | {{{vendorExtensions.x-haddockPath}}}
-- {{#summary}}
-- {{{.}}}
-- {{/summary}}{{#notes}}
-- {{{.}}}
-- {{/notes}}{{#hasAuthMethods}}
-- AuthMethod: {{#authMethods}}{{{name}}}{{#hasMore}}, {{/hasMore}}{{/authMethods}}
-- {{/hasAuthMethods}}{{#hasConsumes}}
-- Consumes: {{#consumes}}{{{mediaType}}}{{#hasMore}}, {{/hasMore}}{{/consumes}}
-- {{/hasConsumes}}{{#hasProduces}}
-- Produces: {{#produces}}{{{mediaType}}}{{#hasMore}}, {{/hasMore}}{{/produces}}{{/hasProduces}}
{{operationId}} 
  :: {{#allParams}}{{#required}}{{dataType}} -- ^ "{{{paramName}}}"{{#description}} - {{/description}} {{{description}}}
  -> {{/required}}{{/allParams}}{{requestType}} {{{vendorExtensions.x-operationType}}} {{vendorExtensions.x-returnType}}
{{operationId}} {{#allParams}}{{#required}}{{{paramName}}} {{/required}}{{/allParams}}=
  _mkRequest "{{httpMethod}}" [{{#pathParams}}{{#vendorExtensions.x-pathPrefix}}"{{.}}",{{/vendorExtensions.x-pathPrefix}}toPath {{{paramName}}}{{#hasMore}},{{/hasMore}}{{/pathParams}}{{#vendorExtensions.x-pathSuffix}}{{#vendorExtensions.x-hasPathParams}},{{/vendorExtensions.x-hasPathParams}}"{{.}}"{{/vendorExtensions.x-pathSuffix}}]{{#allParams}}{{#required}}
    {{#isHeaderParam}}`_addHeader` {{>_headerColl}} ("{{{baseName}}}", {{{paramName}}}){{/isHeaderParam}}{{#isQueryParam}}`_addQuery` {{>_queryColl}} ("{{{baseName}}}", Just {{{paramName}}}){{/isQueryParam}}{{#isFormParam}}`_addForm` {{>_formColl}} ("{{{baseName}}}", {{{paramName}}}){{/isFormParam}}{{#isBodyParam}}`_setBodyLBS` A.encode {{{paramName}}}{{/isBodyParam}}{{/required}}{{/allParams}}{{#isDeprecated}}

{-# DEPRECATED {{operationId}} "" #-}{{/isDeprecated}}

data {{{vendorExtensions.x-operationType}}}{{#hasConsumes}}{{#consumes}}
-- instance Consumes {{{vendorExtensions.x-operationType}}} {{{mediaType}}}{{/consumes}}{{/hasConsumes}}{{#hasProduces}}{{#produces}}
-- instance Produces {{{vendorExtensions.x-operationType}}} {{{mediaType}}}{{/produces}}{{/hasProduces}}{{#vendorExtensions.x-hasOptionalParams}}{{#allParams}}{{^required}}{{#description}}

-- | /Optional Param/ "{{{baseName}}}" - {{{description}}}{{/description}}
instance HasOptionalParam {{{vendorExtensions.x-operationType}}} {{{vendorExtensions.x-paramNameType}}} where
  applyOptionalParam req ({{{vendorExtensions.x-paramNameType}}} xs) =
    {{#isHeaderParam}}req `_addHeader` {{>_headerColl}} ("{{{baseName}}}", xs){{/isHeaderParam}}{{#isQueryParam}}req `_addQuery` {{>_queryColl}} ("{{{baseName}}}", Just xs){{/isQueryParam}}{{#isFormParam}}req `_addForm` {{>_formColl}} ("{{{baseName}}}", xs){{/isFormParam}}{{#isBodyParam}}req `_setBodyLBS` A.encode xs{{/isBodyParam}}{{/required}}{{/allParams}}{{/vendorExtensions.x-hasOptionalParams}}
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
 
-- * {{requestType}}

-- | Represents a request. The "req" type variable is the request type. The "res" type variable is the response type.
data {{requestType}} req res = {{requestType}}
  { rMethod  :: NH.Method   -- ^ Method of {{requestType}}
  , urlPath :: [BSL.ByteString] -- ^ Endpoint of {{requestType}}
  , params   :: Params -- ^ params of {{requestType}}
  }
  deriving (P.Show)


-- * {{requestType}} Helpers

_mkRequest :: NH.Method -- ^ Method 
          -> [BSL.ByteString] -- ^ Endpoint
          -> {{requestType}} req res -- ^ req: Request Type, res: Response Type
_mkRequest m u = {{requestType}} m u _mkParams

_mkParams :: Params
_mkParams = Params [] [] ParamBodyNone

_addHeader :: {{requestType}} req res -> [NH.Header] -> {{requestType}} req res
_addHeader req header = 
    let _params = params req
    in req { params = _params { paramsHeaders = header P.++ paramsHeaders _params } }

_addQuery :: {{requestType}} req res -> [NH.QueryItem] -> {{requestType}} req res
_addQuery req query = 
    let _params = params req 
    in req { params = _params { paramsQuery = query P.++ paramsQuery _params } }

_addForm :: {{requestType}} req res -> WH.Form -> {{requestType}} req res
_addForm req newform = 
    let _params = params req
        form = case paramsBody _params of
            ParamBodyForm _form -> _form
            _ -> mempty
    in req { params = _params { paramsBody = ParamBodyForm (newform <> form) } }

_addMultiFormPart :: {{requestType}} req res -> NH.Part -> {{requestType}} req res
_addMultiFormPart req newpart = 
    let _params = params req
        parts = case paramsBody _params of
            ParamBodyMultiForm _parts -> _parts
            _ -> []
    in req { params = _params { paramsBody = ParamBodyMultiForm (newpart : parts) } }

_setBodyBS :: {{requestType}} req res -> B.ByteString -> {{requestType}} req res
_setBodyBS req body = 
    let _params = params req
    in req { params = _params { paramsBody = ParamBodyBS body } }

_setBodyLBS :: {{requestType}} req res -> BSL.ByteString -> {{requestType}} req res
_setBodyLBS req body = 
    let _params = params req
    in req { params = _params { paramsBody = ParamBodyBSL body } }



-- * Params

-- ** Consumes
class Consumes req content where

-- ** Produces
class Produces req accept where

-- ** HasOptionalParam
-- | Designates the optional parameters of a request
class HasOptionalParam req param where
  {-# MINIMAL applyOptionalParam | (-&-) #-}

  -- | Apply an optional parameter to a request
  applyOptionalParam :: forall res. {{requestType}} req res -> param -> {{requestType}} req res
  applyOptionalParam = (-&-)
  {-# INLINE applyOptionalParam #-}

  -- | infix operator \/ alias for 'addOptionalParam'
  (-&-) :: forall res. {{requestType}} req res -> param -> {{requestType}} req res
  (-&-) = applyOptionalParam
  {-# INLINE (-&-) #-}

infixl 2 -&-

-- | Request Params
data Params = Params
  { paramsQuery :: NH.Query
  , paramsHeaders :: NH.RequestHeaders
  , paramsBody :: ParamBody
  }
  deriving (P.Show)

data ParamBody
  = ParamBodyNone
  | ParamBodyForm WH.Form
  | ParamBodyMultiForm [NH.Part]
  | ParamBodyBS B.ByteString
  | ParamBodyBSL BSL.ByteString
  deriving (P.Show)

toPath
  :: WH.ToHttpApiData a
  => a -> BSL.ByteString
toPath = BSB.toLazyByteString . WH.toEncodedUrlPiece

toHeader :: WH.ToHttpApiData a => (NH.HeaderName, a) -> [NH.Header]
toHeader x = [fmap WH.toHeader x]

toForm :: WH.ToHttpApiData v => (BS8.ByteString, v) -> WH.Form
toForm (k,v) = WH.toForm [(BS8.unpack k,v)]

toQuery :: WH.ToHttpApiData a => (BS8.ByteString, Maybe a) -> [NH.QueryItem]
toQuery x = [(fmap . fmap) toQueryParam x]
  where toQueryParam = TE.encodeUtf8 . WH.toQueryParam

toHeaderColl :: WH.ToHttpApiData a => CollectionFormat -> (NH.HeaderName, [a]) -> [NH.Header]
toHeaderColl c xs = _toColl c toHeader xs

toFormColl :: WH.ToHttpApiData v => CollectionFormat -> (BS8.ByteString, [v]) -> WH.Form
toFormColl c xs = WH.toForm $ fmap unpack $ _toColl c toHeader $ pack xs
  where
    pack (k,v) = (CI.mk k, v)
    unpack (k,v) = (BS8.unpack (CI.original k), BS8.unpack v)

toQueryColl :: WH.ToHttpApiData a => CollectionFormat -> (BS8.ByteString, Maybe [a]) -> NH.Query
toQueryColl c xs = _toCollA c toQuery xs

_toColl :: P.Traversable f => CollectionFormat -> (f a -> [(b, BS8.ByteString)]) -> f [a] -> [(b, BS8.ByteString)]
_toColl c encode xs = fmap (fmap P.fromJust) (_toCollA' c fencode BS8.singleton (fmap Just xs))
  where fencode = fmap (fmap Just) . encode . fmap P.fromJust
        {-# INLINE fencode #-}

_toCollA :: (P.Traversable f, P.Traversable t, P.Alternative t) => CollectionFormat -> (f (t a) -> [(b, t BS8.ByteString)]) -> f (t [a]) -> [(b, t BS8.ByteString)]
_toCollA c encode xs = _toCollA' c encode BS8.singleton xs

_toCollA' :: (P.Monoid c, P.Traversable f, P.Traversable t, P.Alternative t) => CollectionFormat -> (f (t a) -> [(b, t c)]) -> (Char -> c) -> f (t [a]) -> [(b, t c)]
_toCollA' c encode one xs = case c of
  CommaSeparated -> go (one ',')
  SpaceSeparated -> go (one ' ')
  TabSeparated -> go (one '\t')
  PipeSeparated -> go (one '|')
  MultiParamArray -> expandList
  where
    go sep =
      [P.foldl1 (\(sk, sv) (_, v) -> (sk, (combine sep <$> sv <*> v) <|> sv <|> v)) expandList]
    combine sep x y = x <> sep <> y
    expandList = (P.concatMap encode . (P.traverse . P.traverse) P.toList) xs
    {-# INLINE go #-}
    {-# INLINE expandList #-}
    {-# INLINE combine #-}
  
data CollectionFormat
  = CommaSeparated -- ^ CSV format for multiple parameters.
  | SpaceSeparated -- ^ Also called "SSV"
  | TabSeparated -- ^ Also called "TSV"
  | PipeSeparated -- ^ `value1|value2|value2`
  | MultiParamArray -- ^ Using multiple GET parameters, e.g. `foo=bar&foo=baz`. Only for GET params.

-- * Mime Types

data JSON deriving (P.Typeable)
data XML deriving (P.Typeable)
data PlainText deriving (P.Typeable)
data FormUrlEncoded deriving (P.Typeable)
data NoContent deriving (P.Typeable)

class MimeType mtype  where
  mimeType :: P.Proxy mtype -> ME.MediaType
  mimeType = P.head . mimeTypes
  mimeTypes :: P.Proxy mtype -> [ME.MediaType]
  mimeTypes = (: []) . mimeType
  {-# MINIMAL mimeType | mimeTypes #-}

-- | application\/json
instance MimeType JSON where
  mimeTypes _ =
    [ "application" ME.// "json" ME./: ("charset", "utf-8")
    , "application" ME.// "json"
    ]

-- | @application/xml
instance MimeType XML where
  mimeType _ = "application" ME.// "xml"

-- | @application/x-www-form-urlencoded@
instance MimeType FormUrlEncoded where
  mimeType _ = "application" ME.// "x-www-form-urlencoded"

-- | @text/plain;charset=utf-8@
instance MimeType PlainText where
  mimeType _ = "text" ME.// "plain" ME./: ("charset", "utf-8")


-- * Optional Request Params
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}{{#vendorExtensions.x-hasOptionalParams}}{{#allParams}}{{^required}}{{^vendorExtensions.x-duplicate}}
newtype {{{vendorExtensions.x-paramNameType}}} = {{{vendorExtensions.x-paramNameType}}} { un{{{vendorExtensions.x-paramNameType}}} :: {{{dataType}}} } deriving (P.Eq, P.Show)
{{/vendorExtensions.x-duplicate}}{{/required}}{{/allParams}}{{/vendorExtensions.x-hasOptionalParams}}{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
