{-# LANGUAGE CPP #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE RankNTypes #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

-- |
-- Module      : {{title}}.Types
module {{title}}.Types where

import Data.Aeson (FromJSON(..), ToJSON(..))
import Data.Aeson.Types 
import Data.Data (Data, Typeable)
import Data.Text (Text)
import GHC.Generics (Generic)
import Control.Applicative
import Prelude 

import qualified Data.Map as Map
import qualified Data.Text as T

{{#imports}}import {{import}}
{{/imports}}

{{#models}}
{{#model}}

-- * {{classname}}
-- | {{description}}

{{^vendorExtensions.x-customNewtype}}
{{^parent}}
data {{classname}} = {{classname}}
  { {{#vars}}{{name}} :: {{^required}}Maybe{{/required}} {{datatype}}{{#description}} -- ^ {{/description}}{{description}}{{#hasMore}}
  , {{/hasMore}}{{/vars}}
  } deriving (Show, Eq, Data, Typeable, Generic, Ord)

instance FromJSON {{classname}} where
  parseJSON (Object o) =
    {{classname}}
      <$>{{#vars}} o .: "{{baseName}}" {{#hasMore}}
      <*>{{/hasMore}}{{/vars}}
  parseJSON _ = fail "bad {{classname}} parse"

instance ToJSON {{classname}} where
  toJSON {{classname}} {..} =
    object
      [ {{#vars}}"{{baseName}}" .= toJSON {{name}}{{#hasMore}}
      , {{/hasMore}}{{/vars}}
      ]

-- | Construct a value of type {{classname}} (by applying it's required fields, if any)
mk{{classname}}
  :: {{#requiredVars}}{{{datatype}}} -- ^ '{{name}}'{{#description}}:{{/description}} {{description}}
  -> {{/requiredVars}}{{classname}}
mk{{classname}} {{#requiredVars}}{{name}} {{/requiredVars}}=
  {{classname}}
  { {{#vars}}{{#required}}{{name}}{{/required}}{{^required}}{{name}} = {{#isListContainer}}Nothing{{/isListContainer}}{{#isMapContainer}}Nothing{{/isMapContainer}}{{^isContainer}}Nothing{{/isContainer}}{{/required}}{{#hasMore}}
  , {{/hasMore}}{{/vars}}
  }
{-# INLINE mk{{classname}} #-}

{{#vars}}
{{#required}}
-- | {{name}} Lens for {{classname}}
{{name}}L :: Lens_' {{classname}} {{datatype}}
{{name}}L f {{classname}}{..} = (\{{name}} -> {{classname}} { {{name}}, ..} ) <$> f {{name}}
{-# INLINE {{name}}L #-}
{{/required}}
{{^required}}
-- | {{name}} Traversal for {{classname}}
{{name}}T :: Traversal_' {{classname}} {{datatype}}
{{name}}T f s = maybe (pure s) (\a -> (\b -> s { {{name}} = Just b} ) <$> f a) ({{name}} s)
{-# INLINE {{name}}T #-}
{{/required}}

{{/vars}}

{{/parent}}
{{#parent}}
newtype {{classname}} = {{classname}} { un{{classname}} :: {{parent}} } deriving (Show, Eq, Data, Typeable, Generic, Ord, FromJSON, ToJSON)
{{/parent}}
{{/vendorExtensions.x-customNewtype}}
{{#vendorExtensions.x-customNewtype}}
newtype {{classname}} = {{classname}} {{vendorExtensions.x-customNewtype}} deriving (Show, Eq, Data, Typeable, Generic, Ord, FromJSON, ToJSON)
{{/vendorExtensions.x-customNewtype}}

{{/model}}
{{/models}}

type Traversal_' s a = Traversal_ s s a a
type Traversal_ s t a b = forall (f :: * -> *). Applicative f => (a -> f b) -> s -> f t
type Lens_' s a = Lens_ s s a a
type Lens_ s t a b = forall (f :: * -> *). Functor f => (a -> f b) -> s -> f t
