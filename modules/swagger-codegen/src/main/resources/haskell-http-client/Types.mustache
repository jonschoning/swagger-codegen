{-# LANGUAGE CPP #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

-- |
-- Module      : {{title}}.Types
module {{title}}.Types where

import Data.Aeson (FromJSON(..), ToJSON(..))
import Data.Aeson.Types 
import Data.Data (Data, Typeable)
import Data.Text (Text)
import GHC.Generics (Generic)
import Control.Applicative
import Prelude 

import qualified Data.Map as Map
import qualified Data.Text as T
import qualified Data.Vector as V

import qualified Data.ByteString.Char8 as BS8
import qualified Data.ByteString.Lazy.Char8 as BSL

import           Network.HTTP.Client
import qualified Network.HTTP.Types.Method as NHTM

{{#imports}}import {{import}}
{{/imports}}

-- * Request Params

data {{requestType}} = {{requestType}}
  { rMethod  :: NHTM.Method   -- ^ Method of {{requestType}}
  , endpoint :: Text     -- ^ Endpoint of {{requestType}}
  , params   :: [Params] -- ^ Request params of {{requestType}}
  }
data Params
  = Query TupleBS8
  | Body BSL.ByteString
  deriving (Show)

-- | Type alias for query parameters
type TupleBS8 = (BS8.ByteString, BS8.ByteString)

-- * Models

{{#models}}
{{#model}}

-- ** {{classname}}
{{#description}}-- | {{description}}{{/description}}{{#parent}}
-- {{^description}}|{{/description}}
-- Parent: '{{parent}}'{{/parent}}
{{^vendorExtensions.x-customNewtype}}
data {{classname}} = {{classname}}
  { {{#vars}}{{name}} :: {{^required}}Maybe {{/required}}{{datatype}}{{#description}} -- ^ {{/description}}{{description}}{{#hasMore}}
  , {{/hasMore}}{{/vars}}
  } deriving (Show, Eq, Data, Typeable, Generic)

instance FromJSON {{classname}} where
  parseJSON = withObject "{{classname}}" $ \o ->
    {{classname}}
      <$>{{#vars}} o {{#required}}.: {{/required}}{{^required}}.:!{{/required}} "{{baseName}}" {{#hasMore}}
      <*>{{/hasMore}}{{/vars}}

instance ToJSON {{classname}} where
  toJSON {{classname}} {..} =
    omitNulls
      [ {{#vars}}"{{baseName}}" .= {{name}}{{#hasMore}}
      , {{/hasMore}}{{/vars}}
      ]

-- | Construct a value of type '{{classname}}' (by applying it's required fields, if any)
mk{{classname}}
  :: {{#requiredVars}}{{{datatype}}} -- ^ '{{name}}'{{#description}}:{{/description}} {{description}}
  -> {{/requiredVars}}{{classname}}
mk{{classname}} {{#requiredVars}}{{name}} {{/requiredVars}}=
  {{classname}}
  { {{#vars}}{{#required}}{{name}}{{/required}}{{^required}}{{name}} = {{#isListContainer}}Nothing{{/isListContainer}}{{#isMapContainer}}Nothing{{/isMapContainer}}{{^isContainer}}Nothing{{/isContainer}}{{/required}}{{#hasMore}}
  , {{/hasMore}}{{/vars}}
  }

{{/vendorExtensions.x-customNewtype}}
{{#vendorExtensions.x-customNewtype}}
newtype {{classname}} = {{classname}} {{vendorExtensions.x-customNewtype}} deriving (Show, Eq, Data, Typeable, Generic, FromJSON, ToJSON)
{-# WARNING {{classname}} "untested/unimlemented behavior" #-}
{{/vendorExtensions.x-customNewtype}}

{{/model}}
{{/models}}

-- * Utilities

-- | Removes Null fields.  OpenAPI-Specification 2.0 does not allow Null in JSON.
omitNulls :: [(Text, Value)] -> Value
omitNulls = object . filter notNull
  where
    notNull (_, Null) = False
    notNull _ = True
