{-# LANGUAGE CPP #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

-- |
-- Module      : {{title}}.Types
module {{title}}.Types where

import Data.Aeson (FromJSON(..), ToJSON(..))
import Data.Aeson.Types 
import Data.Data (Data, Typeable)
import Data.Text (Text)
import qualified Data.Vector as V
import GHC.Generics (Generic)
import Control.Applicative
import Prelude 

import qualified Data.Map as Map
import qualified Data.Text as T

{{#imports}}import {{import}}
{{/imports}}

{{#models}}
{{#model}}

-- * {{classname}}
-- | {{description}}

{{^vendorExtensions.x-customNewtype}}
{{^parent}}
data {{classname}} = {{classname}}
  { {{#vars}}{{name}} :: {{^required}}Maybe {{/required}}{{datatype}}{{#description}} -- ^ {{/description}}{{description}}{{#hasMore}}
  , {{/hasMore}}{{/vars}}
  } deriving (Show, Eq, Data, Typeable, Generic, Ord)

instance FromJSON {{classname}} where
  parseJSON (Object o) =
    {{classname}}
      <$>{{#vars}} o {{#required}}.: {{/required}}{{^required}}.:!{{/required}} "{{baseName}}" {{#hasMore}}
      <*>{{/hasMore}}{{/vars}}
  parseJSON _ = fail "bad {{classname}} parse"

instance ToJSON {{classname}} where
  toJSON {{classname}} {..} =
    omitNulls
      [ {{#vars}}"{{baseName}}" .= {{name}}{{#hasMore}}
      , {{/hasMore}}{{/vars}}
      ]

-- | Construct a value of type '{{classname}}' (by applying it's required fields, if any)
mk{{classname}}
  :: {{#requiredVars}}{{{datatype}}} -- ^ '{{name}}'{{#description}}:{{/description}} {{description}}
  -> {{/requiredVars}}{{classname}}
mk{{classname}} {{#requiredVars}}{{name}} {{/requiredVars}}=
  {{classname}}
  { {{#vars}}{{#required}}{{name}}{{/required}}{{^required}}{{name}} = {{#isListContainer}}Nothing{{/isListContainer}}{{#isMapContainer}}Nothing{{/isMapContainer}}{{^isContainer}}Nothing{{/isContainer}}{{/required}}{{#hasMore}}
  , {{/hasMore}}{{/vars}}
  }
{-# INLINE mk{{classname}} #-}


{{/parent}}
{{#parent}}
newtype {{classname}} = {{classname}} { un{{classname}} :: {{parent}} } deriving (Show, Eq, Data, Typeable, Generic, Ord, FromJSON, ToJSON)
{{/parent}}
{{/vendorExtensions.x-customNewtype}}
{{#vendorExtensions.x-customNewtype}}
newtype {{classname}} = {{classname}} {{vendorExtensions.x-customNewtype}} deriving (Show, Eq, Data, Typeable, Generic, Ord, FromJSON, ToJSON)
{{/vendorExtensions.x-customNewtype}}

{{/model}}
{{/models}}

-- * Utilities

-- | Removes Null fields.  OpenAPI-Specification 2.0 does not allow Null in JSON.
omitNulls :: [(Text, Value)] -> Value
omitNulls = object . filter notNull
  where
    notNull (_, Null) = False
    notNull _ = True
